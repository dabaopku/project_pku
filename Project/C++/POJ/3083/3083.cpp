// 我真诚地保证：

// 我自己独立地完成了整个程序从分析、设计到编码的所有工作。
// 如果在上述过程中，我遇到了什么困难而求教于人，那么，我将在程序实习报告中
// 详细地列举我所遇到的问题，以及别人给我的提示。

// 在此，我感谢 XXX, …, XXX对我的启发和帮助。下面的报告中，我还会具体地提到
// 他们在各个方法对我的帮助。

// 我的程序里中凡是引用到其他程序或文档之处，
// 例如教材、课堂笔记、网上的源代码以及其他参考书上的代码段,
// 我都已经在程序的注释里很清楚地注明了引用的出处。

// 我从未抄袭过别人的程序，也没有盗用别人的程序，
// 不管是修改式的抄袭还是原封不动的抄袭。

// 我编写这个程序，从来没有想过要去破坏或妨碍其他计算机系统的正常运转。

// 郭聪

// 项目名：ACM3038
// 创建时间：2009－9－26


//文件名称：3083.cpp
//项目名称：3083.vcproj
//创建者：	郭聪
//创建时间：2009-9-26
//最后修改时间：2009-9-26
//功能：	求解ACM3038
//文件中的函数名称和简单功能描述：见具体注释
//文件中定义的全局变量和简单功能描述：见具体注释
//文件中用到的他处定义的全局变量及其出处：无
//与其他文件的依赖关系：无

#include "iostream"
#include "queue"

using namespace std;

char maze[50][50];		//记录迷宫
int step[50][50];		//记录走到每一个格子最短需要几步
int w,h;				//迷宫规格
int sx,sy,ex,ey;		//起点与终点位置
const int dirlf[2][4][2]={	{0,-1,1,0,0,1,-1,0},
							{0,1,1,0,0,-1,-1,0}};
//存储走到相邻格子时坐标的变化情况
//第一维 0代表向左,1代表向右
//第二维 表示 面向一个方向(0~3)时 它的左/右 的 格子坐标与它的差量
//  也就是说 4个分量代表了转一圈需要4次,而方向指明了转圈的起始点
//  方向是按照从小到大的顺序,而转圈是按照从大到小的顺序
//  所以转圈时方向是 dir=(dir+3)%4 进行变化的

struct point			//表示一个点的结构体
{
	int x,y;
	point(int x_=0,int y_=0):x(x_),y(y_){};
};

void init()			//初始化函数,负责读取数据
{
	//函数名称：	init
	//函数功能描述：初始化函数,负责读取数据
	//函数调用之前的预备条件：无
	//返回后的处理：			无
	//返回值（如果有的话）：	无
	//函数的输入参数：			无
	//函数的输出参数：			无
	//函数的抽象算法（伪码）： 无
	//函数与其他对象中函数的调用和被调用关系：无

	memset(maze,'#',sizeof(maze));
	cin>>w>>h;
	for(int i=1;i<=h;i++)
		for(int j=1;j<=w;j++){
			cin>>maze[i][j];
			if(maze[i][j]=='S'){	//如果是起点
				sx=i;
				sy=j;
			} //end if
			else if(maze[i][j]=='E'){	//如果是终点
				ex=i;
				ey=j;
			} //end else
		} //end i
}

int movelf(int type,int dir)	//执行向左/右走的功能,返回走到目标的步数
// type是转向类型,0为向左,1为向右
// dir 是当前面对方向,具体定义在 solve函数中
{
	//函数名称：	moveit
	//函数功能描述：执行向左/右走的功能,返回走到目标的步数
	//函数调用之前的预备条件：solve函数求出dir
	//返回后的处理：			无
	//返回值（如果有的话）：	走到终点的步数
	//函数的输入参数：			type 转向类型  dir 面对方向
	//函数的输出参数：			无
	//函数的抽象算法（伪码）： 模拟
	//函数与其他对象中函数的调用和被调用关系：无

	int x=sx,y=sy;		//获得当前位置坐标
	int ans=1;			//返回值,因为当前位置也要算1步,所以初始化为1
	while(x!=ex || y!=ey){	//模拟走路,循环直到走到终点
		for(int i=0;i<4;i++){	//尝试四个方向,type=1就先尝试向左,否则先尝试向右

			if(maze[x+dirlf[type][dir][0]][y+dirlf[type][dir][1]]!='#'){
				//请参考dirlf的定义
				//如果临边格子可以走就走过去
				ans++;
				x+=dirlf[type][dir][0];	//更新所处位置
				y+=dirlf[type][dir][1];
				dir=(dir+1)%4;		//撤销上一个循环的方向变化,因为走路方向与面对方向相差90度
				break;	//找到路就不再循环了
			} //end if
			dir=(dir+3)%4;	//转向
		} //end for

		//因为题目保证了路的存在,所以没有进行无路可走的判断
	} //end while
	return ans;	//返回结果
}

int bfs()	//广度优先搜索求走到终点的最少步数
{
	//函数名称：	bfs
	//函数功能描述：广度优先搜索求走到终点的最少步数
	//函数调用之前的预备条件：	无
	//返回后的处理：			无
	//返回值（如果有的话）：	走到终点的最少步数
	//函数的输入参数：			无
	//函数的输出参数：			无
	//函数的抽象算法（伪码）： 广度优先搜索
	//函数与其他对象中函数的调用和被调用关系：无

	int i,j;
	const int inf=1000000;		//没有被访问过标记
	for(i=0;i<=h+1;i++){		//初始化 可走格子
		for(j=0;j<=w+1;j++){
			if(maze[i][j]=='.') step[i][j]=inf;
		} //end for j
	} // end for i
	step[sx][sy]=1;		//因为当前位置也要算1步,所以初始化为1
	step[ex][ey]=inf;	//为了减少循环判断单独对终点初始化
	queue<point> que;	//广搜队列,使用 STL 模板库
						//考虑到程序数据规模,为了减少程序的实现难度
						//没有用 priority_queue和估价函数
	que.push(point(sx,sy));//起点进队列
	point cur;				//当前位置
	while(step[ex][ey]==inf && !que.empty()){	
				//其实后一个判断没有用,因为题目保证了解的存在
		cur=que.front();
		que.pop();	//队列弹出第一个节点
		for(i=0;i<4;i++){	//枚举四个方向,如果没有被访问过就更新该节点并进队列
							//方向增量数组直接使用了向左拐的分量,因为枚举没有顺序要求
			if(step[cur.x+dirlf[0][i][0]][cur.y+dirlf[0][i][1]]==inf){
				step[cur.x+dirlf[0][i][0]][cur.y+dirlf[0][i][1]]=
					step[cur.x][cur.y]+1;	//走到它的步数等于当前步数加1
				que.push(point(cur.x+dirlf[0][i][0],cur.y+dirlf[0][i][1]));
			} //end if
		} //end for
	} //end while
	return step[ex][ey];
}
void solve()  //求解问题框架并打印结果
	//函数名称：	solve
	//函数功能描述：求解问题框架并打印结果
	//函数调用之前的预备条件：无
	//返回后的处理：			无
	//返回值（如果有的话）：	无
	//函数的输入参数：			无
	//函数的输出参数：			无
	//函数的抽象算法（伪码）：  无
	//函数与其他对象中函数的调用和被调用关系：无
{
	int dir;
	// 面向上 dir=0
	// 面向左 dir=1
	// 面向下 dir=2
	// 面向右 dir=3

	if(sx==1) dir=2;
	else if(sx==h) dir=0;
	else if(sy==1) dir=1;
	else dir=3;
	//调用各子函数求出结果
	cout<<movelf(0,dir)<<" "<<movelf(1,dir)<<" "<<bfs()<<endl;

}
int main()
{
	int cs;
	cin>>cs;
//	freopen("data.txt","r",stdin);
	while(cs--){ //多 case 处理
		init();
		solve();
	}
	return 0;	//程序结束
}